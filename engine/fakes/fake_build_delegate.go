// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/concourse/atc"
	"github.com/concourse/atc/engine"
	"github.com/concourse/atc/exec"
)

type FakeBuildDelegate struct {
	InputCompletedStub        func(atc.InputPlan) exec.CompleteCallback
	inputCompletedMutex       sync.RWMutex
	inputCompletedArgsForCall []struct {
		arg1 atc.InputPlan
	}
	inputCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	ExecutionCompletedStub        func() exec.CompleteCallback
	executionCompletedMutex       sync.RWMutex
	executionCompletedArgsForCall []struct{}
	executionCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	OutputCompletedStub        func(atc.OutputPlan) exec.CompleteCallback
	outputCompletedMutex       sync.RWMutex
	outputCompletedArgsForCall []struct {
		arg1 atc.OutputPlan
	}
	outputCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	StartStub        func()
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	FinishStub        func() exec.CompleteCallback
	finishMutex       sync.RWMutex
	finishArgsForCall []struct{}
	finishReturns struct {
		result1 exec.CompleteCallback
	}
	AbortedStub        func()
	abortedMutex       sync.RWMutex
	abortedArgsForCall []struct{}
}

func (fake *FakeBuildDelegate) InputCompleted(arg1 atc.InputPlan) exec.CompleteCallback {
	fake.inputCompletedMutex.Lock()
	fake.inputCompletedArgsForCall = append(fake.inputCompletedArgsForCall, struct {
		arg1 atc.InputPlan
	}{arg1})
	fake.inputCompletedMutex.Unlock()
	if fake.InputCompletedStub != nil {
		return fake.InputCompletedStub(arg1)
	} else {
		return fake.inputCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) InputCompletedCallCount() int {
	fake.inputCompletedMutex.RLock()
	defer fake.inputCompletedMutex.RUnlock()
	return len(fake.inputCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) InputCompletedArgsForCall(i int) atc.InputPlan {
	fake.inputCompletedMutex.RLock()
	defer fake.inputCompletedMutex.RUnlock()
	return fake.inputCompletedArgsForCall[i].arg1
}

func (fake *FakeBuildDelegate) InputCompletedReturns(result1 exec.CompleteCallback) {
	fake.InputCompletedStub = nil
	fake.inputCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) ExecutionCompleted() exec.CompleteCallback {
	fake.executionCompletedMutex.Lock()
	fake.executionCompletedArgsForCall = append(fake.executionCompletedArgsForCall, struct{}{})
	fake.executionCompletedMutex.Unlock()
	if fake.ExecutionCompletedStub != nil {
		return fake.ExecutionCompletedStub()
	} else {
		return fake.executionCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) ExecutionCompletedCallCount() int {
	fake.executionCompletedMutex.RLock()
	defer fake.executionCompletedMutex.RUnlock()
	return len(fake.executionCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) ExecutionCompletedReturns(result1 exec.CompleteCallback) {
	fake.ExecutionCompletedStub = nil
	fake.executionCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) OutputCompleted(arg1 atc.OutputPlan) exec.CompleteCallback {
	fake.outputCompletedMutex.Lock()
	fake.outputCompletedArgsForCall = append(fake.outputCompletedArgsForCall, struct {
		arg1 atc.OutputPlan
	}{arg1})
	fake.outputCompletedMutex.Unlock()
	if fake.OutputCompletedStub != nil {
		return fake.OutputCompletedStub(arg1)
	} else {
		return fake.outputCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) OutputCompletedCallCount() int {
	fake.outputCompletedMutex.RLock()
	defer fake.outputCompletedMutex.RUnlock()
	return len(fake.outputCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) OutputCompletedArgsForCall(i int) atc.OutputPlan {
	fake.outputCompletedMutex.RLock()
	defer fake.outputCompletedMutex.RUnlock()
	return fake.outputCompletedArgsForCall[i].arg1
}

func (fake *FakeBuildDelegate) OutputCompletedReturns(result1 exec.CompleteCallback) {
	fake.OutputCompletedStub = nil
	fake.outputCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		fake.StartStub()
	}
}

func (fake *FakeBuildDelegate) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeBuildDelegate) Finish() exec.CompleteCallback {
	fake.finishMutex.Lock()
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub()
	} else {
		return fake.finishReturns.result1
	}
}

func (fake *FakeBuildDelegate) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeBuildDelegate) FinishReturns(result1 exec.CompleteCallback) {
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) Aborted() {
	fake.abortedMutex.Lock()
	fake.abortedArgsForCall = append(fake.abortedArgsForCall, struct{}{})
	fake.abortedMutex.Unlock()
	if fake.AbortedStub != nil {
		fake.AbortedStub()
	}
}

func (fake *FakeBuildDelegate) AbortedCallCount() int {
	fake.abortedMutex.RLock()
	defer fake.abortedMutex.RUnlock()
	return len(fake.abortedArgsForCall)
}

var _ engine.BuildDelegate = new(FakeBuildDelegate)
