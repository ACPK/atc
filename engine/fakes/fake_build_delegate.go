// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/concourse/atc"
	"github.com/concourse/atc/engine"
	"github.com/concourse/atc/exec"
	"github.com/pivotal-golang/lager"
)

type FakeBuildDelegate struct {
	InputCompletedStub        func(lager.Logger, atc.InputPlan) exec.CompleteCallback
	inputCompletedMutex       sync.RWMutex
	inputCompletedArgsForCall []struct {
		arg1 lager.Logger
		arg2 atc.InputPlan
	}
	inputCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	ExecutionCompletedStub        func(lager.Logger) exec.CompleteCallback
	executionCompletedMutex       sync.RWMutex
	executionCompletedArgsForCall []struct {
		arg1 lager.Logger
	}
	executionCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	OutputCompletedStub        func(lager.Logger, atc.OutputPlan) exec.CompleteCallback
	outputCompletedMutex       sync.RWMutex
	outputCompletedArgsForCall []struct {
		arg1 lager.Logger
		arg2 atc.OutputPlan
	}
	outputCompletedReturns struct {
		result1 exec.CompleteCallback
	}
	StartStub        func(lager.Logger)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 lager.Logger
	}
	FinishStub        func(lager.Logger) exec.CompleteCallback
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
		arg1 lager.Logger
	}
	finishReturns struct {
		result1 exec.CompleteCallback
	}
	AbortedStub        func(lager.Logger)
	abortedMutex       sync.RWMutex
	abortedArgsForCall []struct {
		arg1 lager.Logger
	}
}

func (fake *FakeBuildDelegate) InputCompleted(arg1 lager.Logger, arg2 atc.InputPlan) exec.CompleteCallback {
	fake.inputCompletedMutex.Lock()
	fake.inputCompletedArgsForCall = append(fake.inputCompletedArgsForCall, struct {
		arg1 lager.Logger
		arg2 atc.InputPlan
	}{arg1, arg2})
	fake.inputCompletedMutex.Unlock()
	if fake.InputCompletedStub != nil {
		return fake.InputCompletedStub(arg1, arg2)
	} else {
		return fake.inputCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) InputCompletedCallCount() int {
	fake.inputCompletedMutex.RLock()
	defer fake.inputCompletedMutex.RUnlock()
	return len(fake.inputCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) InputCompletedArgsForCall(i int) (lager.Logger, atc.InputPlan) {
	fake.inputCompletedMutex.RLock()
	defer fake.inputCompletedMutex.RUnlock()
	return fake.inputCompletedArgsForCall[i].arg1, fake.inputCompletedArgsForCall[i].arg2
}

func (fake *FakeBuildDelegate) InputCompletedReturns(result1 exec.CompleteCallback) {
	fake.InputCompletedStub = nil
	fake.inputCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) ExecutionCompleted(arg1 lager.Logger) exec.CompleteCallback {
	fake.executionCompletedMutex.Lock()
	fake.executionCompletedArgsForCall = append(fake.executionCompletedArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.executionCompletedMutex.Unlock()
	if fake.ExecutionCompletedStub != nil {
		return fake.ExecutionCompletedStub(arg1)
	} else {
		return fake.executionCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) ExecutionCompletedCallCount() int {
	fake.executionCompletedMutex.RLock()
	defer fake.executionCompletedMutex.RUnlock()
	return len(fake.executionCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) ExecutionCompletedArgsForCall(i int) lager.Logger {
	fake.executionCompletedMutex.RLock()
	defer fake.executionCompletedMutex.RUnlock()
	return fake.executionCompletedArgsForCall[i].arg1
}

func (fake *FakeBuildDelegate) ExecutionCompletedReturns(result1 exec.CompleteCallback) {
	fake.ExecutionCompletedStub = nil
	fake.executionCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) OutputCompleted(arg1 lager.Logger, arg2 atc.OutputPlan) exec.CompleteCallback {
	fake.outputCompletedMutex.Lock()
	fake.outputCompletedArgsForCall = append(fake.outputCompletedArgsForCall, struct {
		arg1 lager.Logger
		arg2 atc.OutputPlan
	}{arg1, arg2})
	fake.outputCompletedMutex.Unlock()
	if fake.OutputCompletedStub != nil {
		return fake.OutputCompletedStub(arg1, arg2)
	} else {
		return fake.outputCompletedReturns.result1
	}
}

func (fake *FakeBuildDelegate) OutputCompletedCallCount() int {
	fake.outputCompletedMutex.RLock()
	defer fake.outputCompletedMutex.RUnlock()
	return len(fake.outputCompletedArgsForCall)
}

func (fake *FakeBuildDelegate) OutputCompletedArgsForCall(i int) (lager.Logger, atc.OutputPlan) {
	fake.outputCompletedMutex.RLock()
	defer fake.outputCompletedMutex.RUnlock()
	return fake.outputCompletedArgsForCall[i].arg1, fake.outputCompletedArgsForCall[i].arg2
}

func (fake *FakeBuildDelegate) OutputCompletedReturns(result1 exec.CompleteCallback) {
	fake.OutputCompletedStub = nil
	fake.outputCompletedReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) Start(arg1 lager.Logger) {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		fake.StartStub(arg1)
	}
}

func (fake *FakeBuildDelegate) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeBuildDelegate) StartArgsForCall(i int) lager.Logger {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1
}

func (fake *FakeBuildDelegate) Finish(arg1 lager.Logger) exec.CompleteCallback {
	fake.finishMutex.Lock()
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub(arg1)
	} else {
		return fake.finishReturns.result1
	}
}

func (fake *FakeBuildDelegate) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeBuildDelegate) FinishArgsForCall(i int) lager.Logger {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return fake.finishArgsForCall[i].arg1
}

func (fake *FakeBuildDelegate) FinishReturns(result1 exec.CompleteCallback) {
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 exec.CompleteCallback
	}{result1}
}

func (fake *FakeBuildDelegate) Aborted(arg1 lager.Logger) {
	fake.abortedMutex.Lock()
	fake.abortedArgsForCall = append(fake.abortedArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.abortedMutex.Unlock()
	if fake.AbortedStub != nil {
		fake.AbortedStub(arg1)
	}
}

func (fake *FakeBuildDelegate) AbortedCallCount() int {
	fake.abortedMutex.RLock()
	defer fake.abortedMutex.RUnlock()
	return len(fake.abortedArgsForCall)
}

func (fake *FakeBuildDelegate) AbortedArgsForCall(i int) lager.Logger {
	fake.abortedMutex.RLock()
	defer fake.abortedMutex.RUnlock()
	return fake.abortedArgsForCall[i].arg1
}

var _ engine.BuildDelegate = new(FakeBuildDelegate)
